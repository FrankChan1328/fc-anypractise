1.基本概念
乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。
1).乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。
	因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
2).悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。
	因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

2.乐观锁实现方式
1).CAS(Compare And Swap)机制
	* CAS 是由CPU 支持的原子操作，其原子性是在硬件层面上保证的

2).版本号机制
	* 基本思路是在数据中增加一个字段version，表示数据的版本，每当数据被修改，版本号加1.
	* 线程更改数据时，判断当前版本号与之前读取的版本号是否一致，一致才进行操作。
	* 也可以用时间戳
	
3.悲观锁的实现方式：加锁
	* 既可以对代码块加锁(如 java 的 synchronized 关键字)
	* 也可以对数据库加锁(如 mysql 的排它锁)
	
4.优缺点和适用场景
乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；
1).功能限制
	与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。
	例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。
	
	再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。

2).竞争激烈程度如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：
	* 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，
		因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
	* 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

5.乐观锁加锁吗？
1).乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。
2).有时乐观锁可能与加锁操作合作，例如，在前述updateCoins()的例子中，MySQL在执行update时会加排它锁。
	但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。

6.CAS有哪些缺点？
下面是CAS一些不那么完美的地方：
1).ABA问题
假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：
	(1)线程1读取内存中数据为A；
	(2)线程2将该数据修改为B；
	(3)线程2将该数据修改为A；
	(4)线程1对数据进行CAS操作

	* 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。
	* 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，
		例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
		对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；
		在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。
		Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。

2).高竞争下的开销问题在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。
	针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。
	当然，更重要的是避免在高竞争环境下使用乐观锁。

3).功能限制CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，这意味着：
	* 原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；
	* 当涉及到多个变量(内存值)时，CAS也无能为力。
	* 除此之外，CAS的实现需要硬件层面处理器的支持，在Java中普通用户无法直接使用，只能借助atomic包下的原子类使用，灵活性受到限制。

参看：
https://zhuanlan.zhihu.com/p/74372722
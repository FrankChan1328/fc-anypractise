内存映射文件(Memory-mapped File)
1).指的是将一段虚拟内存逐字节映射于一个文件，使得应用程序处理文件如同访问主内存(但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作)，这要比直接文件读写快几个数量级;

2).虚拟机内存
区别于物理内存，是一种计算机内存管理技术。使得应用程序认为它拥有连续的可用的内存，实际上是被分割成多个物理内存碎片的，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

3).用处
内存映射文件主要的用处是增加 I/O 性能，特别是针对大文件。
对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界，最小单位是 4 KiB，一个 5 KiB 的文件将会映射占用 8 KiB 内存，也就会浪费 3 KiB 内存。
java.nio 包使得内存映射变得非常简单，其中的核心类叫做 MappedByteBuffer，字面意思为映射的字节缓冲区。

=================================
内存映射文件
1).内存映射文件能让你创建和修改那些因为太大而无法放入内存的文件。
        有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问。
        这种解决办法能大大简化修改文件的代码。

2).fileChannel.map() 方法
    fileChannel.map(FileChannel.MapModemode,long position,long size)
        将此通道的文件区域直接映射到内存中。注意，你必须指明，它是从文件的哪个位置开始映射的，映射的范围又有多大；也就是说，它还可以映射一个大文件的某个小片断。

3).MappedByteBuffer
    MappedByteBuffer是ByteBuffer的子类，因此它具备了ByteBuffer的所有方法，
        但新添了force()将缓冲区的内容强制刷新到存储设备中去、load()将存储设备中的数据加载到内存中、isLoaded()位置内存中的数据是否与存储设置上同步。
        这里只简单地演示了一下put()和get()方法，除此之外，你还可以使用asCharBuffer( )之类的方法得到相应基本类型数据的缓冲视图后，可以方便的读写基本类型数据。
        
4).说明
        尽管映射写似乎要用到FileOutputStream，但是映射文件中的所有输出 必须使用RandomAccessFile，
        但如果只需要读时可以使用FileInputStream，写映射文件时一定要使用随机访问文件，可能写时要读的原因吧。
        该程序创建了一个128Mb的文件，如果一次性读到内存可能导致内存溢出，但这里访问好像只是一瞬间的事，
        这是因为，真正调入内存的只是其中的一小部分，其余部分则被放在交换文件上。这样你就可以很方便地修改超大型的文件了(最大可以到2 GB)。

5).【 注意】Java是调用操作系统的"文件映射机制"来提升性能的。
        内存映射文件是应用虚拟内存的技术来达到加速处理的
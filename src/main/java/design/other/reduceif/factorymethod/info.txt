面试官：你的这种解决方案，有人说使用了工厂模式，你觉得是吗？ 

小白：不是，真正的工厂模式有两种：工厂方法和抽象工厂。
工厂方法使用继承，首先定义一个抽象父类工厂，然后定义子类工厂，把工厂要创建的对象委托给子工厂类，子工厂类实现父工厂类中要创建对象的方法。
抽象工厂使用对象组合，首先定义一个工厂接口，然后定义工厂接口实现类，在实现类中实现接口的方法来创建对象，最后使用组合将接口实现类注入到要创建对象的地方。
还有一种是简单工厂，但它不能算是真正意义上的设计模式，就是通过ifelse方式实现的。



面试官：你觉得工厂模式有什么优缺点？ 

小白：优点就是扩展容易，也不用再修改以前的代码，新增对象创建工厂即可，减少对象创建的依赖和强耦合。
缺点就是会产生很多的工厂类或对象类，管理上会麻烦些，代码变的更多了。


面试官：你刚刚的这种解决方案，如果对象的生命周期是由Spring容器来管理的，也就是bean的实例化是在Spring容器启动时发生的，如何将Addition这种对象实例注入到calculatorMap中？ 
小白：有两种方式，一种是将calculatorMap中的key和value(bean的id)配置到Spring的xml声明文件中，
另一种是通过编码的方式，自定义一个类实现Spring的ApplicationContextAware接口和InitializingBean接口，在类中声明属性一个ApplicationContext，
通过setApplicationContext将这个属性指向Spring容器中的应用上下文ApplicationContext对象，
然后实现afterPropertiesSet方法，通过applicationContext.getBeansOfType(Calculator.class)获取Calculator接口的所有实现类，
结果是一个Map，key是bean的name，value是bean的实例对象，然后遍历这个Map，将元素注入到calculatorMap中。